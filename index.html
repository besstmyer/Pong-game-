<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Shield Pong</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000018;
      touch-action: none;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }
    canvas {
      display: block;
    }
    #hud {
      position: fixed;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 18px;
      text-shadow: 0 0 4px rgba(0,0,0,0.8);
      user-select: none;
      pointer-events: none;
      text-align: center;
      padding: 4px 10px;
    }
  </style>
</head>
<body>
  <div id="hud">Shield Pong</div>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hud = document.getElementById('hud');

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- Audio setup ---
    let audioCtx = null;
    function initAudio() {
      if (!audioCtx) {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (AudioContext) {
          audioCtx = new AudioContext();
        }
      }
    }

    function playBeep(freq = 440, duration = 0.08, volume = 0.2) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.frequency.value = freq;
      osc.type = 'square';
      gain.gain.value = volume;
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      osc.start(now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
      osc.stop(now + duration);
    }

    const MAX_SCORE = 7;

    const paddleWidth = 18;
    const paddleHeight = 120;
    const ballRadius = 16;

    const player = {
      x: 30,
      y: canvas.height / 2 - paddleHeight / 2,
      score: 0,
      hitTimer: 0
    };

    const ai = {
      x: canvas.width - 30 - paddleWidth,
      y: canvas.height / 2 - paddleHeight / 2,
      score: 0,
      hitTimer: 0
    };

    const ball = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      vx: 6,
      vy: 4
    };

    let gameState = 'menu'; // 'menu' | 'playing' | 'gameover'
    let winnerText = '';

    function clampPaddles() {
      player.y = Math.max(0, Math.min(canvas.height - paddleHeight, player.y));
      ai.y = Math.max(0, Math.min(canvas.height - paddleHeight, ai.y));
    }

    function resetBall(direction = 1) {
      ball.x = canvas.width / 2;
      ball.y = canvas.height / 2;
      ball.vx = 6 * direction;
      ball.vy = (Math.random() * 4 - 2);
    }

    function resetScores() {
      player.score = 0;
      ai.score = 0;
    }

    function startGame() {
      initAudio();
      resetScores();
      resetBall(1);
      gameState = 'playing';
      winnerText = '';
    }

    function handlePlayerInput(screenY) {
      if (gameState !== 'playing') return;
      player.y = screenY - paddleHeight / 2;
      clampPaddles();
    }

    // --- Input ---
    canvas.addEventListener('mousemove', (e) => {
      handlePlayerInput(e.clientY);
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      handlePlayerInput(touch.clientY);
    }, { passive: false });

    function handleTap() {
      if (gameState === 'menu' || gameState === 'gameover') {
        startGame();
      }
    }

    canvas.addEventListener('mousedown', () => {
      initAudio();
      handleTap();
    });

    canvas.addEventListener('touchstart', (e) => {
      initAudio();
      handleTap();
    }, { passive: true });

    // --- Particles ---
    const particles = [];

    function spawnBurst(x, y, color, amount = 18, speed = 6) {
      for (let i = 0; i < amount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const mag = Math.random() * speed;
        particles.push({
          x,
          y,
          vx: Math.cos(angle) * mag,
          vy: Math.sin(angle) * mag,
          life: 0.5 + Math.random() * 0.4,
          color
        });
      }
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= dt;
        if (p.life <= 0) {
          particles.splice(i, 1);
          continue;
        }
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 8 * dt * 0.2; // slight gravity
      }
    }

    function drawParticles() {
      particles.forEach(p => {
        const alpha = Math.max(0, p.life * 2);
        ctx.fillStyle = p.color.replace('ALPHA', alpha.toFixed(3));
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // --- Visual helpers ---
    function drawStar(cx, cy, spikes, outerRadius, innerRadius, color, alpha) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      let rot = Math.PI / 2 * 3;
      let x = cx;
      let y = cy;
      const step = Math.PI / spikes;

      ctx.moveTo(cx, cy - outerRadius);
      for (let i = 0; i < spikes; i++) {
        x = cx + Math.cos(rot) * outerRadius;
        y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y);
        rot += step;

        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(x, y);
        rot += step;
      }
      ctx.lineTo(cx, cy - outerRadius);
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
      ctx.restore();
    }

    function drawShieldBall(idleSpin = false, time = 0) {
      let x = ball.x;
      let y = ball.y;

      if (gameState !== 'playing') {
        x = canvas.width / 2;
        y = canvas.height / 2;
      }

      const r = ballRadius;
      const spin = idleSpin ? time * 1.2 : 0;

      // Outer ring - red
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(spin);

      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI * 2);
      ctx.fillStyle = '#c62828';
      ctx.fill();

      // Middle ring - white
      ctx.beginPath();
      ctx.arc(0, 0, r * 0.7, 0, Math.PI * 2);
      ctx.fillStyle = '#f5f5f5';
      ctx.fill();

      // Inner circle - blue
      ctx.beginPath();
      ctx.arc(0, 0, r * 0.45, 0, Math.PI * 2);
      ctx.fillStyle = '#1565c0';
      ctx.fill();

      // Center star
      ctx.beginPath();
      const spikes = 5;
      const outer = r * 0.35;
      const inner = r * 0.18;
      let rot = Math.PI / 2 * 3;
      let sx = 0;
      let sy = 0;
      const step = Math.PI / spikes;

      ctx.moveTo(0, -outer);
      for (let i = 0; i < spikes; i++) {
        sx = Math.cos(rot) * outer;
        sy = Math.sin(rot) * outer;
        ctx.lineTo(sx, sy);
        rot += step;

        sx = Math.cos(rot) * inner;
        sy = Math.sin(rot) * inner;
        ctx.lineTo(sx, sy);
        rot += step;
      }
      ctx.lineTo(0, -outer);
      ctx.closePath();
      ctx.fillStyle = '#f5f5f5';
      ctx.fill();

      ctx.restore();
    }

    function drawBackground(time) {
      const grad = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      grad.addColorStop(0, '#0d1b3d');
      grad.addColorStop(0.5, '#102a6b');
      grad.addColorStop(1, '#1a237e');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const size = Math.min(canvas.width, canvas.height) * 0.25;
      const pulse = 0.04 * Math.sin(time * 1.2);
      drawStar(
        canvas.width / 2,
        canvas.height / 2,
        5,
        size * (1 + pulse),
        (size / 2.4) * (1 + pulse),
        '#ffffff',
        0.06
      );
    }

    function drawPaddlesAndCenter(time) {
      // Center dashed line
      ctx.setLineDash([10, 10]);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 0);
      ctx.lineTo(canvas.width / 2, canvas.height);
      ctx.stroke();
      ctx.setLineDash([]);

      // Animated paddle glow
      function paddleColor(base, hitTimer, time, tint) {
        const t = (Math.sin(time * 4) + 1) * 0.5 * 0.15; // subtle breathing
        const hitBoost = Math.max(0, hitTimer * 2);
        // base is hex '#rrggbb'
        const c = base === 'red' ? { r: 244, g: 67, b: 54 } : { r: 33, g: 150, b: 243 };
        const boost = t + hitBoost;
        const r = Math.min(255, c.r + 60 * boost);
        const g = Math.min(255, c.g + 60 * boost);
        const b = Math.min(255, c.b + 60 * boost);
        return `rgb(${r|0},${g|0},${b|0})`;
      }

      ctx.fillStyle = paddleColor('red', player.hitTimer, time);
      ctx.fillRect(player.x, player.y, paddleWidth, paddleHeight);

      ctx.fillStyle = paddleColor('blue', ai.hitTimer, time);
      ctx.fillRect(ai.x, ai.y, paddleWidth, paddleHeight);
    }

    function drawScores() {
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 28px system-ui, -apple-system, BlinkMacSystemFont, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(player.score, canvas.width * 0.25, 40);
      ctx.fillText(ai.score, canvas.width * 0.75, 40);
    }

    function drawOverlay() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.45)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'center';

      if (gameState === 'menu') {
        ctx.font = 'bold 34px system-ui';
        ctx.fillText('Shield Pong', canvas.width / 2, canvas.height / 2 - 40);

        ctx.font = '18px system-ui';
        ctx.fillText('Drag your finger up & down to move your shield.', canvas.width / 2, canvas.height / 2);
        ctx.fillText('First to 7 points wins.', canvas.width / 2, canvas.height / 2 + 26);

        ctx.font = 'bold 20px system-ui';
        ctx.fillText('Tap anywhere to start', canvas.width / 2, canvas.height / 2 + 70);
      } else if (gameState === 'gameover') {
        ctx.font = 'bold 30px system-ui';
        ctx.fillText(winnerText, canvas.width / 2, canvas.height / 2 - 20);

        ctx.font = '18px system-ui';
        ctx.fillText(`Final score: You ${player.score} – ${ai.score} Rival`, canvas.width / 2, canvas.height / 2 + 10);

        ctx.font = 'bold 20px system-ui';
        ctx.fillText('Tap anywhere to play again', canvas.width / 2, canvas.height / 2 + 55);
      }
    }

    // --- Game logic ---
    let lastTime = performance.now();

    function update(dt) {
      if (gameState !== 'playing') {
        updateParticles(dt);
        return;
      }

      player.hitTimer = Math.max(0, player.hitTimer - dt);
      ai.hitTimer = Math.max(0, ai.hitTimer - dt);

      ball.x += ball.vx;
      ball.y += ball.vy;

      // Wall collision
      if (ball.y - ballRadius < 0 && ball.vy < 0) {
        ball.vy *= -1;
        playBeep(550, 0.06, 0.15);
        spawnBurst(ball.x, ballRadius + 4, 'rgba(220,220,255,ALPHA)', 10, 4);
      }
      if (ball.y + ballRadius > canvas.height && ball.vy > 0) {
        ball.vy *= -1;
        playBeep(550, 0.06, 0.15);
        spawnBurst(ball.x, canvas.height - ballRadius - 4, 'rgba(220,220,255,ALPHA)', 10, 4);
      }

      // Player paddle
      if (
        ball.x - ballRadius < player.x + paddleWidth &&
        ball.y > player.y &&
        ball.y < player.y + paddleHeight &&
        ball.vx < 0
      ) {
        ball.vx *= -1.1;
        const hitPos = (ball.y - (player.y + paddleHeight / 2)) / (paddleHeight / 2);
        ball.vy = hitPos * 6;
        playBeep(420, 0.08, 0.25);
        spawnBurst(player.x + paddleWidth, ball.y, 'rgba(255,120,120,ALPHA)', 18, 7);
        player.hitTimer = 0.3;
      }

      // AI paddle
      if (
        ball.x + ballRadius > ai.x &&
        ball.y > ai.y &&
        ball.y < ai.y + paddleHeight &&
        ball.vx > 0
      ) {
        ball.vx *= -1.1;
        const hitPos = (ball.y - (ai.y + paddleHeight / 2)) / (paddleHeight / 2);
        ball.vy = hitPos * 6;
        playBeep(520, 0.08, 0.23);
        spawnBurst(ai.x, ball.y, 'rgba(120,170,255,ALPHA)', 18, 7);
        ai.hitTimer = 0.3;
      }

      // Scoring
      if (ball.x + ballRadius < 0) {
        ai.score += 1;
        playBeep(260, 0.18, 0.25);
        spawnBurst(canvas.width * 0.75, 40, 'rgba(255,255,255,ALPHA)', 26, 6);
        if (ai.score >= MAX_SCORE) {
          gameOver(false);
        } else {
          resetBall(1);
        }
      }

      if (ball.x - ballRadius > canvas.width) {
        player.score += 1;
        playBeep(720, 0.18, 0.28);
        spawnBurst(canvas.width * 0.25, 40, 'rgba(255,255,255,ALPHA)', 26, 6);
        if (player.score >= MAX_SCORE) {
          gameOver(true);
        } else {
          resetBall(-1);
        }
      }

      // Simple AI
      const target = ball.y;
      const aiSpeed = 4.5;
      if (ai.y + paddleHeight / 2 < target - 10) ai.y += aiSpeed;
      else if (ai.y + paddleHeight / 2 > target + 10) ai.y -= aiSpeed;

      clampPaddles();
      updateParticles(dt);
    }

    function gameOver(playerWon) {
      gameState = 'gameover';
      winnerText = playerWon ? 'You Win!' : 'You Lose!';
      // little rising triad
      if (playerWon) {
        playBeep(660, 0.16, 0.3);
        setTimeout(() => playBeep(880, 0.16, 0.3), 120);
        setTimeout(() => playBeep(1040, 0.2, 0.3), 240);
      } else {
        playBeep(260, 0.18, 0.28);
        setTimeout(() => playBeep(200, 0.22, 0.28), 150);
      }
    }

    function loop(now) {
      const dt = Math.min(0.05, (now - lastTime) / 1000);
      lastTime = now;

      update(dt);

      const t = now / 1000;

      drawBackground(t);
      drawPaddlesAndCenter(t);
      drawShieldBall(gameState !== 'playing', t);
      drawParticles();
      drawScores();

      if (gameState === 'menu') {
        hud.textContent = 'Shield Pong – tap to start';
        drawOverlay();
      } else if (gameState === 'gameover') {
        hud.textContent = 'Game over – tap to play again';
        drawOverlay();
      } else {
        hud.textContent = 'Drag your finger to move your shield';
      }

      requestAnimationFrame(loop);
    }

    resetBall(1);
    requestAnimationFrame(loop);
  </script>
</body>
</html>
